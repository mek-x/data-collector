package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/fs"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

var groups = []string{"collector", "parser", "dispatcher", "sink"}

func modulePath() (string, string, error) {
	// search upward for go.mod so generator works when run from a subdirectory
	dir, err := os.Getwd()
	if err != nil {
		return "", "", err
	}

	for {
		modPath := filepath.Join(dir, "go.mod")
		if _, statErr := os.Stat(modPath); statErr == nil {
			b, err := os.ReadFile(modPath)
			if err != nil {
				return "", "", err
			}
			for _, line := range strings.Split(string(b), "\n") {
				if strings.HasPrefix(strings.TrimSpace(line), "module ") {
					return strings.TrimSpace(strings.TrimPrefix(line, "module ")), dir, nil
				}
			}
			return "", "", fmt.Errorf("module line not found in %s", modPath)
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}

	return "", "", fmt.Errorf("go.mod not found in any parent directory")
}

func main() {
	mod, base, err := modulePath()
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(2)
	}

	var imports []string
	for _, g := range groups {
		dir := filepath.Join(base, "pkg", g)
		ents, _ := os.ReadDir(dir)
		for _, e := range ents {
			if !e.IsDir() || strings.HasPrefix(e.Name(), ".") || strings.HasPrefix(e.Name(), "_") {
				continue
			}
			p := filepath.Join(dir, e.Name())
			hasGo := false
			_ = filepath.WalkDir(p, func(path string, d fs.DirEntry, walkErr error) error {
				if walkErr != nil || d.IsDir() {
					return nil
				}
				if strings.HasSuffix(d.Name(), ".go") {
					hasGo = true
					return fs.SkipDir
				}
				return nil
			})
			if hasGo {
				imports = append(imports, fmt.Sprintf("_ \"%s/pkg/%s/%s\"", mod, g, e.Name()))
			}
		}
	}

	sort.Strings(imports)

	var buf bytes.Buffer
	fmt.Fprintln(&buf, "package modules")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "//go:generate go run ../../tools/genmodules")
	fmt.Fprintln(&buf, "// Code generated by tools/genmodules; DO NOT EDIT.")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "import (")
	for _, imp := range imports {
		fmt.Fprintln(&buf, "\t"+imp)
	}
	fmt.Fprintln(&buf, ")")

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// fallback to unformatted output
		formatted = buf.Bytes()
	}

	outPath := filepath.Join(base, "internal", "modules", "modules.go")
	if err := os.WriteFile(outPath, formatted, 0644); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(2)
	}
}
